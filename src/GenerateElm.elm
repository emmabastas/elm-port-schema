module GenerateElm exposing (generateElm)

import Elm.CodeGen as CodeGen
import Elm.Pretty
import Pretty
import Schema exposing (Schema)
import String.Format exposing (namedValue)


template : String
template =
    """-- This module was autogenerated using elm-port-schema. Do not manually edit
    

port module Port exposing (..)

import Dict
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode


port fromElm : Encode.Value -> Cmd msg


port toElm : (Decode.Value -> msg) -> Sub msg


send : FromElmMessage -> Cmd msg
send =
    fromElm << encodeFromElmMessage


recive : (Result Decode.Error ToElmMessage -> msg) -> Sub msg
recive f =
    toElm (f << Decode.decodeValue decodeToElmMessage)



-- types


{{ typeDeclarations }}



-- codecs


{{ codecs }}



-- prelude


encodeUnit : () -> Encode.Value
encodeUnit _ =
    encodeVariant "()" []


decodeUnit : Decode.Decoder ()
decodeUnit =
    decodeCustomType [ ( "()", Decode.succeed () ) ]


encodeChar : Char -> Encode.Value
encodeChar c =
    Encode.string (String.fromChar c)


decodeChar : Decode.Decoder Char
decodeChar =
    Decode.andThen
        (\\string ->
            case String.toList string of
                [ char ] ->
                    Decode.succeed char

                _ ->
                    Decode.fail
                        ("Expected string of length 1. Got "
                            ++ String.fromInt (String.length string)
                        )
        )
        Decode.string


encodeTuple : (a -> Encode.Value) -> (b -> Encode.Value) -> ( a, b ) -> Encode.Value
encodeTuple encoderA encoderB ( a, b ) =
    Encode.list identity
        [ encoderA a
        , encoderB b
        ]


decodeTuple : Decoder t1 -> Decoder t2 -> Decoder ( t1, t2 )
decodeTuple t1Decoder t2Decoder =
    Decode.map2 Tuple.pair
        (Decode.index 0 t1Decoder)
        (Decode.index 1 t2Decoder)


encodeTuple3 : (a -> Encode.Value) -> (b -> Encode.Value) -> (c -> Encode.Value) -> ( a, b, c ) -> Encode.Value
encodeTuple3 encoderA encoderB encoderC ( a, b, c ) =
    Encode.list identity
        [ encoderA a
        , encoderB b
        , encoderC c
        ]


decodeTuple3 : Decoder t1 -> Decoder t2 -> Decoder t3 -> Decoder ( t1, t2, t3 )
decodeTuple3 t1Decoder t2Decoder t3Decoder =
    Decode.map3 (\\e1 e2 e3 -> ( e1, e2, e3 ))
        (Decode.index 0 t1Decoder)
        (Decode.index 1 t2Decoder)
        (Decode.index 3 t3Decoder)


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe innerEncoder m =
    case m of
        Just inner ->
            encodeVariant "Just" [ innerEncoder inner ]

        Nothing ->
            encodeVariant "Nothing" []


decodeMaybe : Decoder t -> Decoder (Maybe t)
decodeMaybe justDecoder =
    decodeCustomType
        [ ( "Just"
          , Decode.map Just
                (decodeVariantArg 0 justDecoder)
          )
        , ( "Nothing", Decode.succeed Nothing )
        ]


encodeResult : (x -> Encode.Value) -> (a -> Encode.Value) -> Result x a -> Encode.Value
encodeResult errEncoder okEncoder r =
    case r of
        Ok ok ->
            encodeVariant "Ok" [ okEncoder ok ]

        Err err ->
            encodeVariant "Err" [ errEncoder err ]


decodeResult : Decoder e -> Decoder t -> Decoder (Result e t)
decodeResult errorDecoder okDecoder =
    decodeCustomType
        [ ( "Ok"
          , Decode.map Ok (decodeVariantArg 0 okDecoder)
          )
        , ( "Err"
          , Decode.map Err (decodeVariantArg 0 errorDecoder)
          )
        ]


encodeRecord : List ( String, a -> Encode.Value ) -> a -> Encode.Value
encodeRecord fields record =
    Encode.object
        (List.map
            (\\( fieldName, fieldEncoder ) -> ( fieldName, fieldEncoder record ))
            fields
        )


decodeRecordField : String -> Decoder a -> Decoder (a -> b) -> Decoder b
decodeRecordField fieldName fieldDecoder recordDecoder =
    Decode.andThen
        (\\fieldValue -> Decode.map (\\f -> f fieldValue) recordDecoder)
        (Decode.field fieldName fieldDecoder)


decodeCustomType : List ( String, Decoder a ) -> Decoder a
decodeCustomType decoders =
    Decode.andThen
        (\\variant ->
            case Dict.get variant (Dict.fromList decoders) of
                Nothing ->
                    Decode.fail
                        ("Unexpected variant. Expected on of the following: "
                            ++ String.join ", " (List.map Tuple.first decoders)
                        )

                Just variantDecoder ->
                    variantDecoder
        )
        (Decode.field "variant" Decode.string)


encodeVariant : String -> List Encode.Value -> Encode.Value
encodeVariant variantName variantArgs =
    Encode.object
        ([ ( "variant", Encode.string variantName ) ]
            ++ List.indexedMap
                (\\index variantArg ->
                    ( "_" ++ String.fromInt index, variantArg )
                )
                variantArgs
        )


decodeVariant : Decoder String
decodeVariant =
    Decode.field "variant" Decode.string


decodeVariantArg : Int -> Decoder a -> Decoder a
decodeVariantArg n =
    Decode.field ("_" ++ String.fromInt n)
"""


generateElm : Schema -> String
generateElm schema =
    template
        |> namedValue "typeDeclarations"
            (schema.declarations
                |> List.map generateTypeDeclaration
                |> List.map (Elm.Pretty.prettyDeclaration 80)
                |> List.map (Pretty.pretty 80)
                |> String.join "\n\n\n"
            )
        |> namedValue "codecs"
            (schema.declarations
                |> List.concatMap generateCodec
                |> List.map (Elm.Pretty.prettyDeclaration 80)
                |> List.map (Pretty.pretty 80)
                |> String.join "\n\n\n"
            )


generateTypeDeclaration : Schema.Declaration -> CodeGen.Declaration
generateTypeDeclaration declaration =
    case declaration of
        Schema.TypeAliasDeclaration { name, definition } ->
            CodeGen.aliasDecl
                Nothing
                name
                []
                (generateTypeAnnotation definition)

        Schema.CustomTypeDeclaration { name, constructors } ->
            CodeGen.customTypeDecl
                Nothing
                name
                []
                (List.map
                    (\variant ->
                        ( variant.name
                        , List.map generateTypeAnnotation variant.arguments
                        )
                    )
                    constructors
                )


generateCodec : Schema.Declaration -> List CodeGen.Declaration
generateCodec declaration =
    case declaration of
        Schema.TypeAliasDeclaration { name, definition } ->
            [ CodeGen.funDecl
                Nothing
                (Just
                    (CodeGen.funAnn
                        (CodeGen.typed name [])
                        (CodeGen.fqTyped [ "Encode" ] "Value" [])
                    )
                )
                ("encode" ++ name)
                []
                (generateEncoder definition)
            , CodeGen.funDecl
                Nothing
                (Just (CodeGen.typed "Decoder" [ CodeGen.typed name [] ]))
                ("decode" ++ name)
                []
                (generateDecoder definition)
            ]

        Schema.CustomTypeDeclaration customType ->
            [ generateCustomTypeEncoder customType
            , generateCustomTypeDecoder customType
            ]


generateCustomTypeEncoder : Schema.CustomType -> CodeGen.Declaration
generateCustomTypeEncoder { name, constructors } =
    CodeGen.funDecl
        Nothing
        (Just
            (CodeGen.funAnn
                (CodeGen.typed name [])
                (CodeGen.fqTyped [ "Encode" ] "Value" [])
            )
        )
        ("encode" ++ name)
        [ CodeGen.varPattern "v" ]
        (CodeGen.caseExpr
            (CodeGen.val "v")
            (List.map
                (\variant ->
                    let
                        argNames =
                            List.indexedMap
                                (\i _ -> "a" ++ String.fromInt i)
                                variant.arguments

                        argVariablePatterns =
                            List.map CodeGen.varPattern argNames

                        argVariables =
                            List.map CodeGen.val argNames

                        argEncoders =
                            List.map generateEncoder variant.arguments
                    in
                    ( CodeGen.namedPattern variant.name argVariablePatterns
                    , CodeGen.apply
                        [ CodeGen.fun "encodeVariant"
                        , CodeGen.string variant.name
                        , CodeGen.list
                            (List.map2
                                (\argVariable argEncoder ->
                                    CodeGen.apply
                                        [ argEncoder
                                        , argVariable
                                        ]
                                )
                                argVariables
                                argEncoders
                            )
                        ]
                    )
                )
                constructors
            )
        )


generateCustomTypeDecoder : Schema.CustomType -> CodeGen.Declaration
generateCustomTypeDecoder { name, constructors } =
    CodeGen.funDecl
        Nothing
        (Just (CodeGen.typed "Decoder" [ CodeGen.typed name [] ]))
        ("decode" ++ name)
        []
        (CodeGen.apply
            [ CodeGen.fun "decodeCustomType"
            , CodeGen.list
                (List.map
                    (\variant ->
                        let
                            variantArgs =
                                List.length variant.arguments
                        in
                        if variantArgs == 0 then
                            CodeGen.tuple
                                [ CodeGen.string variant.name
                                , CodeGen.apply
                                    [ CodeGen.fqFun [ "Decode" ] "succeed"
                                    , CodeGen.construct variant.name []
                                    ]
                                ]

                        else
                            let
                                mapFunction =
                                    if variantArgs == 1 then
                                        CodeGen.fqFun [ "Decode" ] "map"

                                    else
                                        CodeGen.fqFun
                                            [ "Decode" ]
                                            ("map" ++ String.fromInt variantArgs)
                            in
                            CodeGen.tuple
                                [ CodeGen.string variant.name
                                , CodeGen.apply
                                    ([ mapFunction
                                     , CodeGen.construct variant.name []
                                     ]
                                        ++ List.indexedMap
                                            (\i arg ->
                                                CodeGen.pipe
                                                    (generateDecoder arg)
                                                    [ CodeGen.apply
                                                        [ CodeGen.fqFun [ "Decode" ] "field"
                                                        , CodeGen.string ("_" ++ String.fromInt i)
                                                        ]
                                                    ]
                                                    |> CodeGen.parens
                                            )
                                            variant.arguments
                                    )
                                ]
                    )
                    constructors
                )
            ]
        )


generateTypeAnnotation : Schema.Type -> CodeGen.TypeAnnotation
generateTypeAnnotation schemaType =
    case schemaType of
        Schema.Unit ->
            CodeGen.unitAnn

        Schema.Bool ->
            CodeGen.boolAnn

        Schema.Int ->
            CodeGen.intAnn

        Schema.Float ->
            CodeGen.floatAnn

        Schema.Char ->
            CodeGen.charAnn

        Schema.String ->
            CodeGen.stringAnn

        Schema.List t ->
            CodeGen.listAnn (generateTypeAnnotation t)

        Schema.Tuple t1 t2 ->
            CodeGen.tupleAnn (List.map generateTypeAnnotation [ t1, t2 ])

        Schema.Tuple3 t1 t2 t3 ->
            CodeGen.tupleAnn (List.map generateTypeAnnotation [ t1, t2, t3 ])

        Schema.Record fields ->
            List.map
                (\{ name, type_ } -> ( name, generateTypeAnnotation type_ ))
                fields
                |> CodeGen.recordAnn

        Schema.TypeRef name ->
            CodeGen.typed name []

        Schema.Maybe t ->
            CodeGen.maybeAnn (generateTypeAnnotation t)

        Schema.Result e t ->
            CodeGen.typed "Result" (List.map generateTypeAnnotation [ e, t ])


generateEncoder : Schema.Type -> CodeGen.Expression
generateEncoder type_ =
    (case type_ of
        Schema.Unit ->
            CodeGen.fun "encodeUnit"

        Schema.Bool ->
            CodeGen.fqFun [ "Encode" ] "bool"

        Schema.Int ->
            CodeGen.fqFun [ "Encode" ] "int"

        Schema.Float ->
            CodeGen.fqFun [ "Encode" ] "float"

        Schema.Char ->
            CodeGen.fun "encodeChar"

        Schema.String ->
            CodeGen.fqFun [ "Encode" ] "string"

        Schema.List t ->
            CodeGen.apply
                [ CodeGen.fqFun [ "Encode" ] "list"
                , generateEncoder t
                ]

        Schema.Tuple t1 t2 ->
            CodeGen.apply
                [ CodeGen.fun "encodeTuple"
                , generateEncoder t1
                , generateEncoder t2
                ]

        Schema.Tuple3 t1 t2 t3 ->
            CodeGen.apply
                [ CodeGen.fun "encodeTuple3"
                , generateEncoder t1
                , generateEncoder t2
                , generateEncoder t3
                ]

        Schema.Record fields ->
            CodeGen.apply
                [ CodeGen.fun "encodeRecord"
                , CodeGen.list
                    (List.map
                        (\field ->
                            CodeGen.tuple
                                [ CodeGen.string field.name
                                , CodeGen.applyBinOp
                                    (generateEncoder field.type_)
                                    CodeGen.composel
                                    (CodeGen.accessFun ("." ++ field.name))
                                ]
                        )
                        fields
                    )
                ]

        Schema.TypeRef name ->
            CodeGen.fun ("encode" ++ name)

        Schema.Maybe t ->
            CodeGen.apply
                [ CodeGen.fun "encodeMaybe"
                , generateEncoder t
                ]

        Schema.Result e t ->
            CodeGen.apply
                [ CodeGen.fun "encodeResult"
                , generateEncoder e
                , generateEncoder t
                ]
    )
        |> CodeGen.parens


generateDecoder : Schema.Type -> CodeGen.Expression
generateDecoder type_ =
    (case type_ of
        Schema.Unit ->
            CodeGen.fun "decodeUnit"

        Schema.Bool ->
            CodeGen.fqFun [ "Decode" ] "bool"

        Schema.Int ->
            CodeGen.fqFun [ "Decode" ] "int"

        Schema.Float ->
            CodeGen.fqFun [ "Decode" ] "float"

        Schema.Char ->
            CodeGen.fun "decodeChar"

        Schema.String ->
            CodeGen.fqFun [ "Decode" ] "string"

        Schema.List t ->
            CodeGen.apply
                [ CodeGen.fqFun [ "Decode" ] "list"
                , generateDecoder t
                ]

        Schema.Tuple t1 t2 ->
            CodeGen.apply
                [ CodeGen.fun "decodeTuple"
                , generateDecoder t1
                , generateDecoder t2
                ]

        Schema.Tuple3 t1 t2 t3 ->
            CodeGen.apply
                [ CodeGen.fun "decodeTuple3"
                , generateDecoder t1
                , generateDecoder t2
                , generateDecoder t3
                ]

        Schema.Record fields ->
            CodeGen.pipe
                (CodeGen.apply
                    [ CodeGen.fqFun [ "Decode" ] "succeed"
                    , CodeGen.lambda
                        (List.map
                            (\field -> CodeGen.varPattern field.name)
                            fields
                        )
                        (CodeGen.record
                            (List.map
                                (\field -> ( field.name, CodeGen.val field.name ))
                                fields
                            )
                        )
                    ]
                )
                (List.map
                    (\field ->
                        CodeGen.apply
                            [ CodeGen.fun "decodeRecordField"
                            , CodeGen.string field.name
                            , generateDecoder field.type_
                            ]
                    )
                    fields
                )

        Schema.TypeRef name ->
            CodeGen.apply
                [ CodeGen.fqFun [ "Decode" ] "lazy"
                , CodeGen.lambda
                    [ CodeGen.unitPattern ]
                    (CodeGen.fun ("decode" ++ name))
                ]

        Schema.Maybe t ->
            CodeGen.apply
                [ CodeGen.fun "decodeMaybe"
                , generateDecoder t
                ]

        Schema.Result e t ->
            CodeGen.apply
                [ CodeGen.fun "decodeResult"
                , generateDecoder e
                , generateDecoder t
                ]
    )
        |> CodeGen.parens
